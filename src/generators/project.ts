import fs from "node:fs";
import path from "node:path";
import spawn from "cross-spawn";
import * as prompts from "@clack/prompts";
import type { FrameworkVariant, PkgInfo } from "../types/index.js";
import { replacePackageManagerInCommand } from "../utils/package-manager.js";

export async function executeMultiStepCommands(
  variant: FrameworkVariant,
  targetDir: string,
  root: string,
  cwd: string,
  pkgInfo?: PkgInfo
): Promise<void> {
  if (!variant.multiStepCommands) return;

  prompts.log.step(`Setting up ${variant.display} project...`);

  for (const stepCommand of variant.multiStepCommands) {
    prompts.log.step(stepCommand.description);

    const workingDirectory = stepCommand.workingDir === "target" ? root : cwd;
    let command = stepCommand.command.replace(/TARGET_DIR/g, targetDir);

    // Replace package manager commands with user's preferred package manager
    command = replacePackageManagerInCommand(command, pkgInfo);

    // Parse the command and arguments
    const [cmd, ...args] = command.split(" ");

    try {
      const result = spawn.sync(cmd, args, {
        stdio: "inherit",
        cwd: workingDirectory,
      });

      if (result.status !== 0) {
        prompts.log.error(`Failed to execute: ${command}`);
        process.exit(result.status ?? 1);
      }
    } catch (error) {
      prompts.log.error(`Error executing command: ${command}`);
      console.error(error);
      process.exit(1);
    }
  }
}

export function createProjectFiles(template: string, root: string): void {
  // Add configuration files for specific project types
  if (template === "nextjs-csr") {
    createNextjsCSRFiles(root);
  }

  if (template === "nextjs-ssr") {
    createNextjsSSRFiles(root);
  }

  if (template === "vue3") {
    createVue3Files(root);
  }

  if (template === "electron-react") {
    createElectronReactFiles(root);
  }

  if (template === "electron-vue") {
    createElectronVueFiles(root);
  }
}

function createNextjsCSRFiles(root: string): void {
  const prettierConfig = {
    semi: true,
    trailingComma: "all",
    singleQuote: true,
    printWidth: 80,
    tabWidth: 2,
    useTabs: false,
    importOrder: ["^@core/(.*)$", "^@server/(.*)$", "^@ui/(.*)$", "^[./]"],
    importOrderSeparation: true,
    importOrderSortSpecifiers: true,
    endOfLine: "auto",
    plugins: [
      "prettier-plugin-tailwindcss",
      "@trivago/prettier-plugin-sort-imports",
    ],
  };

  fs.writeFileSync(
    path.join(root, ".prettierrc"),
    JSON.stringify(prettierConfig, null, 2)
  );

  const eslintConfig = `module.exports = {
  extends: ['next/core-web-vitals', 'prettier'],
};`;

  fs.writeFileSync(path.join(root, ".eslintrc.js"), eslintConfig);

  // Create next.config.js with environment-specific configuration
  const nextConfig = `import { format } from 'date-fns';

const nextConfig = {};

const proxy = async () => {
  return [
    {
      source: '/api/:path*',
      destination: 'http://localhost:8000/api/:path*',
    },
  ];
};

switch (process.env.NODE_ENV) {
  case 'production':
    nextConfig.output = 'export';
    nextConfig.images = {};
    nextConfig.images.unoptimized = true;
    nextConfig.distDir = 'dist';
    break;
  case 'development':
    nextConfig.rewrites = proxy;
    break;
}

process.env.NEXT_PUBLIC_BUILD_TIME = format(new Date(), 'yyyy-MM-dd HH:mm');

export default nextConfig;`;

  fs.writeFileSync(path.join(root, "next.config.js"), nextConfig);

  // Create layout file with IE compatibility configuration
  const layoutContent = `import type { Metadata } from 'next';
import { Inter } from 'next/font/google';
import './globals.css';

const inter = Inter({ subsets: ['latin'] });

export const metadata: Metadata = {
  title: 'Create Next App',
  description: 'Generated by create next app',
};

export default function RootLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <html lang="en" suppressHydrationWarning>
      <head>
        <meta httpEquiv="X-UA-Compatible" content="IE=edge,chrome=1" />
        <meta name="renderer" content="webkit" />
        <meta
          name="viewport"
          content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"
        />
        {/* eslint-disable-next-line @next/next/no-before-interactive-script-outside-document */}
        <script
          dangerouslySetInnerHTML={{
            __html: \`
              (function() {
                var isIE = /MSIE|Trident/.test(navigator.userAgent);
                var isOldIE = /MSIE [1-9]\\.|MSIE 10\\./.test(navigator.userAgent);
                if (isOldIE) {
                  window.location.href = '/ie.html';
                }
              })();
            \`,
          }}
        />
      </head>
      <body className={inter.className} suppressHydrationWarning>
        {children}
      </body>
    </html>
  );
}`;

  fs.writeFileSync(path.join(root, "src", "app", "layout.tsx"), layoutContent);

  // Create IE compatibility page in public directory by reading from assets
  const ieHtmlPath = path.join(
    path.dirname(new URL(import.meta.url).pathname),
    "../assets/html/ie.html"
  );

  let ieHtmlContent = "";
  try {
    ieHtmlContent = fs.readFileSync(ieHtmlPath, "utf-8");
  } catch (error) {
    // Fallback content if file doesn't exist
    ieHtmlContent = `<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta httpEquiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="renderer" content="webkit" />
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
    <title>æµè§ˆå™¨å…¼å®¹æ€§æç¤º</title>
</head>
<body>
    <h1>è¯·å‡çº§æ‚¨çš„æµè§ˆå™¨</h1>
    <p>æ‚¨æ­£åœ¨ä½¿ç”¨è¿‡æ—¶çš„æµè§ˆå™¨ç‰ˆæœ¬ï¼Œè¯·å‡çº§åˆ°ç°ä»£æµè§ˆå™¨ä»¥è·å¾—æ›´å¥½çš„ä½“éªŒã€‚</p>
</body>
</html>`;
  }

  // Ensure public directory exists
  const publicDir = path.join(root, "public");
  if (!fs.existsSync(publicDir)) {
    fs.mkdirSync(publicDir, { recursive: true });
  }

  fs.writeFileSync(path.join(publicDir, "ie.html"), ieHtmlContent);

  // Create .devcontainer/devcontainer.json
  const devcontainerConfig = {
    name: "node:v22.9.0",
    image: "mcr.microsoft.com/devcontainers/typescript-node:1-22-bookworm",
    customizations: {
      vscode: {
        extensions: [
          "bradlc.vscode-tailwindcss",
          "esbenp.prettier-vscode",
          "dbaeumer.vscode-eslint",
          "ms-vscode.js-debug",
          "yoavbls.pretty-ts-errors",
          "github.vscode-github-actions",
        ],
      },
    },
    remoteUser: "node",
    mounts: [
      "source=${localEnv:HOME}/.ssh,target=/home/node/.ssh,type=bind,readonly",
      "source=/etc/localtime,target=/etc/localtime,type=bind",
      "source=/etc/timezone,target=/etc/timezone,type=bind",
    ],
    remoteEnv: {
      SSH_AUTH_SOCK: "/ssh-agent",
      TZ: "Asia/Shanghai",
    },
    initializeCommand: "mkdir -p ${localEnv:HOME}/.ssh",
    runArgs: [
      "--volume=/run/host-services/ssh-auth.sock:/ssh-agent",
      "--network=host",
      "--privileged",
    ],
  };

  const devcontainerDir = path.join(root, ".devcontainer");
  if (!fs.existsSync(devcontainerDir)) {
    fs.mkdirSync(devcontainerDir, { recursive: true });
  }
  fs.writeFileSync(
    path.join(devcontainerDir, "devcontainer.json"),
    JSON.stringify(devcontainerConfig, null, 2)
  );

  // Create not-found.tsx
  const notFoundContent = `import Link from 'next/link';

export default function NotFound() {
  return (
    <div className="flex min-h-screen flex-col items-center justify-center">
      <h2 className="text-2xl font-bold">é¡µé¢æœªæ‰¾åˆ°</h2>
      <p className="mt-4 text-gray-600">æŠ±æ­‰ï¼Œæ‚¨è®¿é—®çš„é¡µé¢ä¸å­˜åœ¨ã€‚</p>
      <Link
        href="/"
        className="mt-6 rounded bg-blue-500 px-4 py-2 text-white hover:bg-blue-600"
      >
        è¿”å›é¦–é¡µ
      </Link>
    </div>
  );
}`;

  fs.writeFileSync(
    path.join(root, "src", "app", "not-found.tsx"),
    notFoundContent
  );

  // Create Show component
  const showComponentContent = `interface ShowProps {
  when: boolean;
  fallback?: React.ReactNode;
}

export default function Show({
  children,
  when,
  fallback = null,
}: React.PropsWithChildren<ShowProps>) {
  return when ? children : fallback;
}`;

  const componentsDir = path.join(root, "src", "components");
  if (!fs.existsSync(componentsDir)) {
    fs.mkdirSync(componentsDir, { recursive: true });
  }
  fs.writeFileSync(path.join(componentsDir, "show.tsx"), showComponentContent);

  // Create BuildInfo hook component
  const buildInfoContent = `'use client';

import { useEffect } from 'react';

import pkg from '../../package.json';

export default function BuildInfo() {
  useEffect(() => {
    const print = (key: string, value: string) =>
      console.log(
        \`%c \${key} %c \${value} %c \`,
        'background:#20232a ; padding: 1px; border-radius: 3px 0 0 3px;  color: #fff',
        'background:#61dafb ;padding: 1px; border-radius: 0 3px 3px 0;  color: #20232a; font-weight: bold;',
        'background:transparent',
      );
    print(pkg.name, pkg.version);
    print('build time', \`\${process.env.NEXT_PUBLIC_BUILD_TIME}\`);
  }, []);
  return null;
}`;

  fs.writeFileSync(
    path.join(componentsDir, "build-info.tsx"),
    buildInfoContent
  );

  // Create ThemeProvider
  const themeProviderContent = `'use client';

import { ThemeProvider as NextThemesProvider } from 'next-themes';
import * as React from 'react';

export function ThemeProvider({ children }: React.PropsWithChildren) {
  return (
    <NextThemesProvider
      attribute="class"
      defaultTheme="system"
      enableSystem
      disableTransitionOnChange
    >
      {children}
    </NextThemesProvider>
  );
}`;

  const providersDir = path.join(root, "src", "components", "providers");
  if (!fs.existsSync(providersDir)) {
    fs.mkdirSync(providersDir, { recursive: true });
  }
  fs.writeFileSync(
    path.join(providersDir, "theme-provider.tsx"),
    themeProviderContent
  );

  // Create QueryProvider
  const queryProviderContent = `'use client';

import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
import { ReactQueryDevtools } from '@tanstack/react-query-devtools';
import { useState } from 'react';

export function QueryProvider({ children }: { children: React.ReactNode }) {
  const [queryClient] = useState(
    () =>
      new QueryClient({
        defaultOptions: {
          queries: {
            // æ•°æ®ç¼“å­˜æ—¶é—´ (é»˜è®¤ 5 åˆ†é’Ÿ)
            staleTime: 5 * 60 * 1000,
            // æ•°æ®åœ¨å†…å­˜ä¸­çš„ç¼“å­˜æ—¶é—´ (é»˜è®¤ 5 åˆ†é’Ÿ)
            gcTime: 5 * 60 * 1000,
            // é‡è¯•æ¬¡æ•°
            retry: 3,
            // é‡è¯•å»¶è¿Ÿ
            retryDelay: (attemptIndex) =>
              Math.min(1000 * 2 ** attemptIndex, 30000),
            // çª—å£é‡æ–°è·å¾—ç„¦ç‚¹æ—¶æ˜¯å¦é‡æ–°è·å–æ•°æ®
            refetchOnWindowFocus: false,
            // ç½‘ç»œé‡æ–°è¿æ¥æ—¶æ˜¯å¦é‡æ–°è·å–æ•°æ®
            refetchOnReconnect: true,
          },
          mutations: {
            // é‡è¯•æ¬¡æ•°
            retry: 1,
            // é‡è¯•å»¶è¿Ÿ
            retryDelay: 1000,
          },
        },
      })
  );

  return (
    <QueryClientProvider client={queryClient}>
      {children}
      {/* {process.env.NODE_ENV === 'development' && (
        <ReactQueryDevtools initialIsOpen={false} />
      )} */}
    </QueryClientProvider>
  );
}`;

  fs.writeFileSync(
    path.join(providersDir, "query-provider.tsx"),
    queryProviderContent
  );

  // Create environment files
  const envContent = `NEXT_PUBLIC_API_URL='/api'`;

  fs.writeFileSync(path.join(root, ".env.development"), envContent);
  fs.writeFileSync(path.join(root, ".env.production"), envContent);
  fs.writeFileSync(path.join(root, ".env.test"), envContent);

  // Create request.ts utility
  const requestContent = `/**
 * HTTP è¯·æ±‚ç±»å°è£…ï¼ˆå¼ºç±»å‹ï¼Œæ—  anyï¼‰
 * é…åˆ React Query ä½¿ç”¨ï¼Œç®€åŒ–è¶…æ—¶å’Œé‡è¯•é€»è¾‘
 */

import { toast } from 'sonner';

interface RequestConfig {
  baseURL?: string;
  headers?: Record<string, string>;
}

interface RequestOptions extends RequestInit {
  params?: Record<string, string | number | boolean>;
  data?: unknown; // ç”¨äºä¼ é€’è¯·æ±‚ä½“
}

interface ApiResponse<T> {
  data: T;
  status?: number;
  ok?: boolean;
  code?: number; // åç«¯ä¸šåŠ¡çŠ¶æ€ç 
  msg?: string | null; // åç«¯æ¶ˆæ¯
}

// åç«¯ API å“åº”ç»“æ„
interface BackendResponse<T> {
  code: number;
  msg: string | null;
  data: T;
}

export class HttpClient {
  private baseURL: string;
  private defaultHeaders: Record<string, string>;

  constructor(config: RequestConfig = {}) {
    this.baseURL = config.baseURL || '';
    this.defaultHeaders = {
      'Content-Type': 'application/json',
      ...config.headers,
    };
  }
  updateToken(token: string) {
    // this.defaultHeaders['Authorization'] = \`Bearer \${token}\`;
    this.defaultHeaders['token'] = \`\${token}\`;
  }

  private buildURL(url: string, params?: Record<string, unknown>): string {
    let fullURL = url.startsWith('http') ? url : \`\${this.baseURL}\${url}\`;

    if (params) {
      const searchParams = new URLSearchParams();
      Object.entries(params).forEach(([key, value]) => {
        if (value !== null && value !== undefined) {
          searchParams.append(key, String(value));
        }
      });
      const paramString = searchParams.toString();
      if (paramString) {
        fullURL += \`\${fullURL.includes('?') ? '&' : '?'}\${paramString}\`;
      }
    }

    return fullURL;
  }

  async request<T>(
    url: string,
    options: RequestOptions = {}
  ): Promise<ApiResponse<T>> {
    const { params, data, ...fetchOptions } = options;

    const fullURL = this.buildURL(url, params);

    const headers: HeadersInit = {
      ...this.defaultHeaders,
      ...(fetchOptions.headers || {}),
    };

    let body = fetchOptions.body;

    // å¦‚æœæä¾›äº† dataï¼Œä¼˜å…ˆä½¿ç”¨
    if (data !== undefined) {
      if (data instanceof FormData) {
        body = data;
        Reflect.deleteProperty(headers, 'Content-Type'); // FormData ä¸éœ€è¦æ‰‹åŠ¨è®¾ç½® Content-Type
      } else {
        body = JSON.stringify(data);
      }
    }
    try {
      const response = await fetch(fullURL, {
        ...fetchOptions,
        headers,
        body,
      });
      const contentType = response.headers.get('content-type');
      let responseData: T;
      if (contentType?.includes('application/json')) {
        const jsonResponse: BackendResponse<T> = await response.json();
        if (jsonResponse.code == 401) {
          // æ¸…é™¤æœ¬åœ°å­˜å‚¨
          localStorage.clear();

          // é€€å‡ºç”¨æˆ·çŠ¶æ€
          if (typeof window !== 'undefined') {
            // åŠ¨æ€å¯¼å…¥storeé¿å…å¾ªç¯ä¾èµ–
            import('@/store')
              .then(({ useStore }) => {
                const { logout, openLoginDialog } = useStore.getState();
                logout();
                openLoginDialog();
              })
              .catch(console.error);
          }

          toast.error('ç™»å½•ä¿¡æ¯å·²è¿‡æœŸï¼Œè¯·é‡æ–°ç™»å½•');
        }
        return jsonResponse;
      } else if (contentType?.startsWith('text/')) {
        responseData = (await response.text()) as T;
      } else {
        responseData = (await response.blob()) as T;
      }

      return {
        data: responseData,
        status: response.status,
        ok: response.ok,
      };
    } catch (error: unknown) {
      if (error instanceof Error) {
        throw new Error(error.message);
      }
      throw new Error('ç½‘ç»œè¯·æ±‚å¤±è´¥');
    }
  }

  // GET è¯·æ±‚
  get<T>(
    url: string,
    params?: Record<string, string | number | boolean>,
    options?: Omit<RequestOptions, 'params'>
  ) {
    return this.request<T>(url, { ...options, method: 'GET', params });
  }

  // POST è¯·æ±‚
  post<T = unknown, B = unknown>(
    url: string,
    data?: B,
    options?: Omit<RequestOptions, 'data'>
  ) {
    return this.request<T>(url, { ...options, method: 'POST', data });
  }

  // PUT è¯·æ±‚
  put<T = unknown, B = unknown>(
    url: string,
    data?: B,
    options?: Omit<RequestOptions, 'data'>
  ) {
    return this.request<T>(url, { ...options, method: 'PUT', data });
  }

  // PATCH è¯·æ±‚
  patch<T = unknown, B = unknown>(
    url: string,
    data?: B,
    options?: Omit<RequestOptions, 'data'>
  ) {
    return this.request<T>(url, { ...options, method: 'PATCH', data });
  }

  // DELETE è¯·æ±‚
  delete<T = unknown>(url: string, options?: RequestOptions) {
    return this.request<T>(url, { ...options, method: 'DELETE' });
  }

  // ä¸Šä¼ æ–‡ä»¶
  upload<T = unknown>(
    url: string,
    formData: FormData,
    options?: Omit<RequestOptions, 'data' | 'body'>
  ) {
    return this.request<T>(url, { ...options, method: 'POST', data: formData });
  }
}

// åˆ›å»ºé»˜è®¤å®ä¾‹
export const http = new HttpClient({
  baseURL: \`\${process.env.NEXT_PUBLIC_API_URL || '/api'}\`,
});

// å¿«æ·å¯¼å‡ºå‡½æ•°
export const get = http.get.bind(http);
export const post = http.post.bind(http);
export const put = http.put.bind(http);
export const patch = http.patch.bind(http);
export const del = http.delete.bind(http);
export const upload = http.upload.bind(http);

export default http;`;

  const utilsDir = path.join(root, "src", "utils");
  if (!fs.existsSync(utilsDir)) {
    fs.mkdirSync(utilsDir, { recursive: true });
  }
  fs.writeFileSync(path.join(utilsDir, "request.ts"), requestContent);
}

function createNextjsSSRFiles(root: string): void {
  const prettierConfig = {
    semi: true,
    trailingComma: "es5",
    singleQuote: true,
    printWidth: 80,
    tabWidth: 2,
    useTabs: false,
  };

  fs.writeFileSync(
    path.join(root, ".prettierrc"),
    JSON.stringify(prettierConfig, null, 2)
  );

  const eslintConfig = `module.exports = {
  extends: ['next/core-web-vitals', 'prettier'],
  rules: {
    '@typescript-eslint/no-unused-vars': 'error',
    '@typescript-eslint/no-explicit-any': 'warn',
  },
};`;

  fs.writeFileSync(path.join(root, ".eslintrc.js"), eslintConfig);

  // Create a basic auth setup for SSR
  const envLocal = `NEXTAUTH_URL=http://localhost:3000
NEXTAUTH_SECRET=your-secret-key
DATABASE_URL="your-database-url"`;

  fs.writeFileSync(path.join(root, ".env.local"), envLocal);
  fs.writeFileSync(path.join(root, ".env.example"), envLocal);
}

function createVue3Files(root: string): void {
  const prettierConfig = {
    semi: true,
    trailingComma: "es5",
    singleQuote: true,
    printWidth: 80,
    tabWidth: 2,
    useTabs: false,
  };

  fs.writeFileSync(
    path.join(root, ".prettierrc"),
    JSON.stringify(prettierConfig, null, 2)
  );

  const viteConfig = `import { defineConfig } from 'vite'
import vue from '@vitejs/plugin-vue'
import { resolve } from 'path'

export default defineConfig({
  plugins: [vue()],
  resolve: {
    alias: {
      '@': resolve(__dirname, 'src'),
    },
  },
})`;

  fs.writeFileSync(path.join(root, "vite.config.ts"), viteConfig);
}

function createElectronReactFiles(root: string): void {
  const prettierConfig = {
    semi: true,
    trailingComma: "es5",
    singleQuote: true,
    printWidth: 80,
    tabWidth: 2,
    useTabs: false,
  };

  fs.writeFileSync(
    path.join(root, ".prettierrc"),
    JSON.stringify(prettierConfig, null, 2)
  );

  const eslintConfig = `module.exports = {
  extends: ['electron', '@electron-toolkit/eslint-config-ts', 'prettier'],
  rules: {
    '@typescript-eslint/no-unused-vars': 'error',
    '@typescript-eslint/no-explicit-any': 'warn',
  },
};`;

  fs.writeFileSync(path.join(root, ".eslintrc.js"), eslintConfig);
}

function createElectronVueFiles(root: string): void {
  const prettierConfig = {
    semi: true,
    trailingComma: "es5",
    singleQuote: true,
    printWidth: 80,
    tabWidth: 2,
    useTabs: false,
  };

  fs.writeFileSync(
    path.join(root, ".prettierrc"),
    JSON.stringify(prettierConfig, null, 2)
  );

  const eslintConfig = `module.exports = {
  extends: ['electron', '@electron-toolkit/eslint-config-ts', 'prettier'],
  rules: {
    '@typescript-eslint/no-unused-vars': 'error',
    '@typescript-eslint/no-explicit-any': 'warn',
  },
};`;

  fs.writeFileSync(path.join(root, ".eslintrc.js"), eslintConfig);
}

export function generateSuccessMessage(
  targetDir: string,
  pkgManager: string
): string {
  return `ğŸ‰ Project created successfully!
    
Next steps:
  cd ${targetDir}
  ${pkgManager === "yarn" ? "yarn dev" : `${pkgManager} run dev`}`;
}
